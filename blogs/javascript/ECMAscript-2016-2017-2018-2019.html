<!doctype html>
<html lang="en">
  <head>
    <title>JavaScript Upgrades post 2015: ES7 | ES8 | ES9 | ES10</title>
    <meta name="robots" content="FOLLOW,INDEX" />
    <meta name="description" content="This article comprises all features of ECMAScript 2016 to 2019 i.e. async-await, Object prototype methods, Promise prototype methods and much more." />
    
    <!-- Canonical tag of the page-->
    <link rel="canonical" href="https://indar.xyz/blogs/javascript/ECMAscript-2016-2017-2018-2019.html" />

    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <!--CSS -->
    <link rel="stylesheet" href="../../css/style.css" />
    <link rel="stylesheet" href="../../css/blog-inner.css" />
    <link rel="stylesheet" href="../../css/prism.css" />
    <link href="https://fonts.googleapis.com/css?family=Roboto:100,300,400,500,700,900" rel="stylesheet">


  </head>
  <body>

    <section class="in blog-inner">
      <header>
        <a href="../../index.html" class="logo"><img src="../../images/logo.png" alt="" /></a>
         <span class="hamburger-box hamburger hamburger--squeeze"> <span class="hamburger-inner"></span></span>
        <ul class="nav vis-desk">
          <li><a href="../../about.html">About</a></li>
          <li><a href="../../work.html">Bits</a></li>
          <li class="active-nav"><a href="../../blogs.html">Blogs</a></li>
          <li><a href="../../contact.html">Contact</a></li>
          <li><a href="../../Indrjit-Resume.pdf">Resume</a></li>
        </ul>
      </header>
      <ul class="mob-nav vis-mob">
          <li><a href="../../about.html">About</a></li>
          <li><a href="../../work.html">Bits</a></li>
          <li><a href="../../blogs.html">Blogs</a></li>
          <li><a href="../../contact.html">Contact</a></li>
          <li><a href="../../Indrjit-Resume.pdf">Resume</a></li>
      </ul>


      <section class="blog-holder">

        <header class="blog-header">
          <div class="header-container">
            <div class="heading-content">
              <h1>JavaScript (ES7 | ES8 | ES9 | ES10) </h1>
              <h3>This article will walk you through 'Javascript' upgrades post ES6. (Part-1)</h3>
            </div>
            <div class="social-share">
              <span>SHARE: </span> <!-- Go to www.addthis.com/dashboard to customize your tools --> <div class="addthis_inline_share_toolbox"></div>
            </div>
          </div>
        </header>
        <section>
          <div class="container-content">
            <p>If JavaScript is part of your dev stack or you have people around working with JavaScript, you would know how powerful and popular JavaScript has become since the release of ES6.
ES6 was the biggest release of all time in JS history and a much-needed facelift JavaScript needed to come back to the game. 
After pushing these many upgrades in one shot, TC39 (Unit of ECMA international which takes care of standards of JavaScript) has decided to push a version out every single year, so it doesn’t become too heavy on developers to get aligned with it.
So, all releases have come in subsequent years after that and not to mention they were very small releases compared to ES6.</p>
<p>Let’s see what are those upgrades.
</p>

            <h2>ES7<span>(2016)</span></h2>
            <ul>
              <li>
                <h3>Exponentiation operator</h3>
                <p>The exponentiation operator (**) returns the result of raising the first operand to the power of the second operand. It is equivalent to Math.pow, except it also accepts BigInts as operands.</p>
                <pre>
<code class="language-js">
2 ** 3 //  2 * 2 * 2 = 8
2 ** 5 // 2*2*2*2*2 = 32
</code>
</pre>
              </li>
              <li>
                <h3>Array.prototype.includes</h3>
                <p>The includes() method determines whether an array includes a certain value among its entries, returning true or false.</p>
<pre>
<code class="language-js">
[1,2,3,4].includes(2) // true
["q", "w", "e", "r", "t", "y"].includes("John") // false
</code>
</pre>

              </li>
            </ul>
             <h2>ES8 <span>(2017)</span></h2>
<ul>
              <li>
                <h3>Async|await functions</h3>
                <p>The  <i>async</i> and  <i>await</i> keywords enable asynchronous, promise-based behavior to be written in a cleaner style, avoiding the need to explicitly configure promise chains.</p>
                <p>Async function comes with one golden rule: It always returns a promise(resolved or rejected). The word “async” before a function makes a function async. Let's look at the syntax.</p>
                <pre>
<code class="language-js">
async function foo(parameter1, parameter2, ...paramaterN) {
    // statements
}

// Check this out
async function foo() {
  return 1;
}
foo().then(alert); // 1

// We could explicitly return a promise, which would be the same:
async function foo() {
  return Promise.resolve(1);
}
foo().then(alert); // 1
</code>
</pre>

<p>The keyword <i>await</i> makes JavaScript wait until that promise settles and returns its result(Trick is, it works only inside of async functions). Let's look at the syntax:

 <pre>
<code class="language-js">
// works only inside async functions
let value = await promise; 

// Here’s an example with a promise that resolves in 1 second:
async function foo() {
  let promise = new Promise((resolve, reject) => {
    setTimeout(() => resolve("done!"), 1000)
  });
  let result = await promise; // wait until the promise resolves (*)
  alert(result); // "done!"
}

foo();
</code>
</pre>
<p><i>await</i> literally suspends the function execution until the promise settles, and then resumes it with the promise result. That doesn’t cost any CPU resources, because the JavaScript engine can do other jobs in the meantime: execute other scripts, handle events, etc.<br>

It’s just a more elegant syntax of getting the promise result than promise.then. And, it’s easier to read and write.</p>
 <pre>
<code class="language-js">

// Let's look at a real world scenerio where you would need data from first api call to pass to second and so on:

function fetchData(url, userId, customerId){
  // return promise...
}

async function call(){
const result1 = await fetchData(url) // data1 - JS will wait for this to complete to go to next line of execution.
const result2 = await fetchData(url2, result1.id) // data2
const result3 = await fetchData(url3, result1.id, result2.id) // data3
}

call();

</code>
</pre>

              </li>
              <li>
                <h3>Object.prototype.values</h3>
                <p>The Object.values() method returns an array of a given object's own enumerable property values.</p>
<pre>
<code class="language-js">
const obj = {name: "Jhon", lastName: "Wick"}
Object.values(obj) // ["John", "Wick"]
</code> 
</pre>

              </li>
              <li>
                <h3>Object.prototype.entries</h3>
                <p>The Object.entries() method returns an array of a given object's own enumerable string-keyed property [key, value] pairs.</p>
<pre>
<code class="language-js">
const obj = {name: "Jhon", lastName: "Wick"}
Object.entries(obj) // [["name", John"], ["lastName", Wick"]]
</code>
</pre>

              </li>
              <li>
                <h3>Object.prototype.getOwnPropertyDescriptors</h3>
                <p>The Object.getOwnPropertyDescriptors() method returns all own property descriptors of a given object.</p>
<pre>
<code class="language-js">
const obj = {name: "Jhon", lastName: "Wick"}
const descriptors = Object.getOwnPropertyDescriptors(obj); 

console.log(descriptors) // { name: { value: "John", writable: true, enumerable: true, configurable: true } }
console.log(descriptors.name.writable) // true
</code>
</pre>

              </li>
              <li>
                <h3>String.prototype.padStart and String.prototype.padEnd</h3>
                <p>The padStart() and padEnd() method pads the current string with another string (multiple times, if needed) until the resulting string reaches the given length. The padding is applied from the start of the current string with padStart and from the end with padEnd.</p>
<pre>
<code class="language-js">
“abc”.padStart(10, 1) // “1111111abc”
“abc”.padStart(10) // “       abc”
“abc.padStart(6, “qwerty”) // “qweabc”

“abc”.padEnd(10, 1) // “abc1111111”
“abc”.padEnd(10) // “abc       ”
“abc.padEnd(6, “qwerty”) // “abcqwe”

</code>
</pre>

              </li>
            </ul>

            <h2>ES9<span>(2018)</span></h2>
            <ul>
              <li>
                <h3>Asynchronous iteration</h3>
                <p>a variation of the for-of iteration statement which iterates over async iterable objects. Let's look at the example to understand this:</p>
                <pre>
<code class="language-js">
async function fetchJSON(){
  const promises = [
  fetchJSON(file1.json),
  fetchJSON(file2.json),
  fetchJSON(file3.json),
  fetchJSON(file4.json),
  ]

  // Normal Iterator
  for(const x of promises){
    console.log(x) // logs promise...
  }


  // Async Iterator
  for await(const x of promises){
    console.log(x) // logs a resolved response.
  }
}
</code>
</pre>
              </li>
              <li>
                <h3>Rest|Spread into object literals</h3>
                <p><i>Rest</i> and <i>Spread</i> go hand in hand. Rest allows us to pass an indefinite number of parameters to a function and access them in an array where The spread operator “spreads” the values in an iterable (arrays, strings) across zero or more arguments or elements. </p>
                  <p>The Rest/Spread Properties for ECMAScript proposal (ES2018) added Rest properties for object destructuring assignment and Spread properties for object literals. It copies own enumerable properties from a provided object onto a new object.</p>

                  <p>Let's look at an example to understand how spreading works with an object.</p>
<pre>
<code class="language-js">
// Rest properties
const {name, ...others} = {name: "John", lastName: "Wick", profession: "BogeyMan"}
console.log(name) // "John"
console.log(others) // {lastName: "Wick", profession: "BogeyMan"}


// Spread properties
const hero = {name, ...others}
console.log(hero) // name: "John", lastName: "Wick", profession: "BogeyMan"}


// This will give TypeError
let obj = {'key1': 'value1'};
let array = [...obj]; // TypeError: obj is not iterable
</code>
</pre>

              </li>
              <li>
                <h3>Promise.prototype.finally</h3>
                <p>A finally callback execute logic once your Promise has been settled one way or the other. It has absolutely no impact on the value that your promise will resolve to.</p>
                <p>The idea of finally is to set up a handler for performing cleanup/finalizing after the previous operations are complete.

E.g. stopping loading indicators, closing no longer needed connections etc.</p>
<p>A finally handler has no arguments. In finally we don’t know whether the promise is successful or not. That’s all right, as our task is usually to perform “general” finalizing procedures and the promise outcome is handled in the next handler.
 </p>
<pre>
<code class="language-js">
new Promise((resolve, reject) => {
  setTimeout(() => resolve("value"), 2000);
})
  .finally(() => alert("Promise ready")) // triggers first
  .then(result => alert(result)); // <-- .then shows "value"
</code>
</pre>

              </li>
            </ul>
            <h2>ES10<span>(2019)</span></h2>
            <ul>
              <li>
                <h3>Optional catch binding</h3>
                <p>The Optional Catch Binding allows us to use the try/catch statement without passing the error parameter inside the catch block. It is optional for you whether you want to pass the error variable or not.</p>
                <pre>
<code class="language-js">
// Wihout optional catch binding
  try {
    throw new Error("Some random error");
  } catch (error) {
    console.log(error)
  }

// With optional catch binding
  try {
    throw new Error("Hey");
  } catch {
    console.log("No parameter for catch");
  }
</code>
</pre>
              </li>
              <li>
                <h3>Object.prototype.fromEntries</h3>
                <p>This method is used to transforms a list of key-value pairs into an object. This method returns a new object whose properties are given by the entries of the iterable</p>
<pre>
<code class="language-js">
const mapArr = new Map(
    [['student1', 'Intern'],
    ['student2', 'Manager']]
);
const person = Object.fromEntries(mapArr);
console.log(person); // Object { student1: "Intern", student2: "Manager" }
</code>
</pre>

              </li>
              <li>
                <h3>String.prototype.{trimStart,trimEnd}</h3>
                <p>The trimStart(alias~trimLeft) and trimEnd(alias~trimRight) method removes whitespace from the string. The trimStart() method removes whitespace from the beginning of a string where trimEnd() method removes whitespace from the end of a string. </p>
                <pre>
<code class="language-js">
const greeting = '   Hello world!   ';
console.log(greeting); // "   Hello world!   ";

console.log(greeting.trimStart()); // "Hello world!   ";
console.log(greeting.trimEnd()); // "Hello world!";
</code>
</pre>
              </li>
              <li>
                <h3>Array.prototype.{flat,flatMap}</h3>
                <p>The <i>flat()</i> method creates a new array with all sub-array elements concatenated into it recursively up to the specified depth.<br> Let's look at few examples:</p>
<pre>
<code class="language-js">
const arr = [1,2,3,[4,5]]
console.log(arr.flat()) // [1, 2, 3, 4, 5]

const arr2 = [1,2,3,[4,5,[6,7,[8,9]]]]
console.log(arr2.flat()) // [1, 2, 3, 4, 5, [6, 7, [8, 9]]]
console.log(arr2.flat(2)) // [1, 2, 3, 4, 5, 6, 7, [8, 9]]
console.log(arr2.flat(3)) // [1, 2, 3, 4, 5, 6, 7, 8, 9]
</code>
</pre>

     <p>The <i>flatMap()</i> method returns a new array formed by applying a given callback function to each element of the array, and then flattening the result by one level. It is identical to a map() followed by a flat() of depth 1.<br> Let's look at few examples:</p>
<pre>
<code class="language-js">
const arr1 = [1, 2, 3, 4];

arr1.map(x => [x * 2]); // [[2], [4], [6], [8]]
arr1.flatMap(x => [x * 2]); // [2, 4, 6, 8]

// only one level is flattened
arr1.flatMap(x => [[x * 2]]); // [[2], [4], [6], [8]]
</code>
</pre>

              </li>
              <!-- <li>
                <h3>Function.prototype.toString revision</h3>
                <p>The toString() method returns a string representing the source code of the function.Earlier white spaces,new lines and comments will be removed when you do now they are retained with original source code.</p>
                <pre>
<code class="language-js">
2 ** 3 //  2 * 2 * 2 = 8
2 ** 5 // 2*2*2*2*2 = 32
</code>
</pre>
              </li> -->
              <li>
                <h3>Well-formed JSON.stringify</h3>
                <p>JSON.stringify was previously specified to return ill-formed Unicode strings if the input contains any lone surrogates:</p>
<pre>
<code class="language-js">
JSON.stringify('\uD800'); // → '"�"'
</code>
</pre>
<p>The well-formed <i>JSON.stringify</i> proposal changes JSON.stringify so it outputs escape sequences for lone surrogates, making its output valid Unicode (and representable in UTF-8):</p>
<pre>
<code class="language-js">
JSON.stringify('\uD800'); // → '"\\ud800"'
</code>
</pre>

              </li>
              
            </ul>

             <!-- <div class="note">
              <p>This article will merely give you basic idea of features not the whole concept. I urge you to read more about them. </p>
             </div> -->

          </div>
           <div class="series-block">
            <h6><strong>Series:</strong> JS Upgrades</h6>
            <h2>JavaScript (ES11 | ES12 | ES13) </h1>
            <h4>This article will walk you through 'Javascript' upgrades post ES10. (Part-2)</h3>
              <a href="ECMAscript-2020-2021-2022.html">Read More</a>
          </div>
          <div class="related-blogs-holder">
            <h2>Take a look at other related articles you might find helpful: </h2>
            <ul>
              <li><a href="ECMAscript-2016-2017-2018-2019.html"><strong>JavaScript Upgrades(1).</strong> This article comprises of features added between year 2016-2019. </a></li>
              <li><a href="ECMAscript-2020-2021-2022.html"><strong>JavaScript Upgrades(2).</strong> This article comprises of features added between year 2020-2022. </a></li>
              <!-- <li><a href=""><strong>Vestibulum pellentesque</strong> tempus odio ac congue. </a></li>
              <li><a href=""><strong>Class aptent taciti sociosqu ad litora torquent</strong> per conubia nostra, per inceptos himenaeos. </a></li>
              <li><a href=""><strong>Nam egestas posuere</strong> lorem in scelerisque. Integer at ante ex. </a></li>
              <li><a href=""><strong>Etiam tempus</strong> mi in mi sagittis, non consequat velit accumsan. </a></li> -->
            </ul>
          </div>
        </section>

        <div id="disqus_thread"></div>
        <script>

        /**
        *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
        *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
        
        var disqus_config = function () {
        this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
        this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
        };
        
        (function() { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');
        s.src = 'https://indrjit.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
        })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>



      </section>
      <footer>
        Copyright © <script>document.write(new Date().getFullYear())</script>. All Rights Reserved.
      </footer>

    <!-- Optional JavaScript -->
    <!-- jQuery first, then Popper.js, then Bootstrap JS -->
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="../script/prism.js"></script>
    <script>
      $(window).on('scroll', function () {
        $('.blog-inner > header').toggleClass('shadow', $(document).scrollTop() > 20);
    }).scroll();  //
    </script>

    <script src="../script/main.js"></script>
    <script src="../prism.js"></script>
      <!-- Go to www.addthis.com/dashboard to customize your tools -->
    <script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5baf5e219b1c14ce"></script>

  </body>
</html>
